\newpage
\section{Wybrane aspekty realizacji}

\subsection{Preprocesing}
Preprocesing to proces przygotowywania danych wejściowych tak by nadawały się do szkolenia sieci.

W naszej pracy preprocesing dzieli się na dwa etapy:
\begin{enumerate}
	\item Redukcja alfabetu (mapowanie znaków)
	\item Zamiana zredukowanych tekstów na one hot encoding
\end{enumerate}

Domyślnie dostępnymi językami w bibliotece są:
\languages 
 

\subsubsection{Redukcja alfabetu}
\TODO{Dodac definicje alfabetu}
Redukcja alfabetu pozwala na zredukowanie złożności obliczeniowej oraz zmniejsza wpływ bardzo rzadko
występujących znaków na model języka. Pierwszym krok to normalizacja znaków (NKFD). 
\TODO{NKFD - wyjasnic} 
Przykładowo dla języka polskiego litera \texttt{ó}| została by zdekomponowana do litery o oraz znaku oznaczającego kreskę.
Następnie wykonywany jest szereg zdefiniowanych mapowań takich jak:
\begin{enumerate}
  \item Zamiana każdej cyfry na cyfrę 7
  \item Znaki nie występujące w danym alfabecie są usuwane
  \item Wielkie litery zastępowane są odpowiadającym im małym literom oraz prefiksem
  \item Znaki interpunkcyjne sprowadzane do kanoniczej formy
\end{enumerate}
\newpage
\TODO{jakiego pliku, co to za plik}
Przykładowy fragment pliku do redukcji alfabetu języka
angielskiego znajduje się poniżej (został on znacznie skrócony wzlgędem oryginału żeby zachować lepszą
czytelność)

\begin{python}
charmap = {
    u'V': u'\xb9v',     
    u'K': u'\xb9k',         
    u'Q': u'\xb9q',        
    u'U': u'\xb9u',   
    u'_': '',             
    u':': u':',             
    u'[': u'(',           
    u'(': u'(',               
    u')': u')',              
    u']': u')',              
    u'}': u')',              
    u'{': u'(',                 
}
\end{python}

Tak przygotowany maper pozwala na zamianę wybranych znaków, które nie są kluczowe w procesie 
szkolenia sieci na wybrane inne znaki. Jeśli znak nie jest ujęty w maperze, nie jest zamieniany. 

\subsubsection{Zamiana tekstów na kodowanie one-hot encoding}
Teksty zamieniamy na tablice składająca się z wektorów w kodowaniu one-hot encoding. 
Aby tego dokonać potrzebny jest nam alfabet. Alfabet definiujemy jako listę, której 
elementy są znakami. Tak wygląda fragment alfabetu z języka angielskiego:
\begin{python}
alphabet = [
    ' ',
    'e',
    't',
    'o',
    'a',
    'n',
    'i',
    's',
    'h',
    'r',  # 10
    '\\n',
    'l',
    'd',
    'u',
    'y',
    'm',
]
\end{python}

Każdy znak zredukowanego pliku wejściowego zamieniany jest na wektor wykorzystując alfabet, 
a wektory 'umieszczane' są w tablicy i zapisywane do pliku. Przykład:

Załóżmy że nasz alfabet wygląda następująco:

\begin{python}
alphabet = [
    'a',  #0
    'b',  #1
    'c',  #2
    'd',  #3
 ]
\end{python} 
Jeśli zamienimy literę 'a' na wektor otrzymamy: 
 
\vspace{2mm}
$
\begin{bmatrix} 
1, & 0, & 0, & 0
\end{bmatrix} 
$
\vspace{2mm}

Ponieważ litera 'a' jest na pozycji 0 w alfabecie liczba 1 pojawiła się na pozycji 0 w wektorze.
Długość wektora wynosi 4 ponieważ tyle znaków znajduje się w alfabecie.

W ten sposób konwertowane są wszystkie znaki.
Każdy autor ma odrębną tablice, której elementami są wyżej wspomniane wektory umieszczane tam zgodnie 
z kolejnością ich występowania w tekście. 
Następnie następuje zapis do pliku, a później w procesie uczenia podział na batche.